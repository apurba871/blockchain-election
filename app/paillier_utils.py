from phe import paillier
from phe.util import int_to_base64, base64_to_int
import phe, json

'''
  Important URL's:
  1. https://deapsecure.gitlab.io/deapsecure-lesson05-crypt/21-paillier-he/index.html
  2. https://python-paillier.readthedocs.io/en/develop/phe.html#module-phe.command_line
'''

'''
    See the main() for an working example
    0. Generate public and private key pair and return the JSONified keys
    1. JSON private key dump and return string
    2. JSON private key load and return PaillierPrivateKey object
    3. base64 public key n dump and return string
    4. base64 public key n load and return PaillierPublicKey
    5. Encrypt value using public key and return (ciphertext, exponent)
    6. Decrypt value using private key and return plaintext
'''
def n_to_pub_jwk(n):
    from datetime import datetime
    date = datetime.now().strftime('%Y-%m-%dT%H:%M:%S')
    return {
        'kty': 'DAJ',
        'alg': 'PAI-GN1',
        'key_ops': ['encrypt'],
        'n': n,
        'kid': 'Paillier public key generated by phe on {}'.format(date)
    }

def keypair_dump_jwk(pub, priv, date=None):
    """Serializer for public-private keypair, to JWK format."""
    from datetime import datetime
    if date is None:
        date = datetime.now().strftime('%Y-%m-%dT%H:%M:%S')

    # We only need to store and display n for PUBLIC KEY
    rec_pub = {
        'kty': 'DAJ',
        'alg': 'PAI-GN1',
        'key_ops': ['encrypt'],
        'n': phe.util.int_to_base64(pub.n),
        'kid': 'Paillier public key generated by phe on {}'.format(date)
    }

    # We need to display the values of both p and q, and let the user
    # this json file for PRIVATE KEY
    rec_priv = {
        'kty': 'DAJ',
        'key_ops': ['decrypt'],
        'p': phe.util.int_to_base64(priv.p),
        'q': phe.util.int_to_base64(priv.q),
        'kid': 'Paillier private key generated by phe on {}'.format(date)
    }

    priv_jwk = json.dumps(rec_priv,indent=4)
    pub_jwk = json.dumps(rec_pub,indent=4)
    return pub_jwk, priv_jwk

def publickey_load_jwk(pub_jwk):
    """Deserializer for public key from JWK format."""
    rec_pub = json.loads(pub_jwk)
    # Do some basic checks                                                                                                                                                      
    assert rec_pub['kty'] == "DAJ", "Invalid public key type"
    assert rec_pub['alg'] == "PAI-GN1", "Invalid public key algorithm"
    pub_n = phe.util.base64_to_int(rec_pub['n'])
    pub = paillier.PaillierPublicKey(pub_n)
    return pub

def keypair_load_jwk(pub_jwk, priv_jwk):
    """Deserializer for public-private keypair, from JWK format."""
    rec_pub = json.loads(pub_jwk)
    rec_priv = json.loads(priv_jwk)
    # Do some basic checks                                                                                                                                                      
    assert rec_pub['kty'] == "DAJ", "Invalid public key type"
    assert rec_pub['alg'] == "PAI-GN1", "Invalid public key algorithm"
    assert rec_priv['kty'] == "DAJ", "Invalid private key type"
    pub_n = phe.util.base64_to_int(rec_pub['n'])
    pub = paillier.PaillierPublicKey(pub_n)
    priv_p = phe.util.base64_to_int(rec_priv['p'])
    priv_q = phe.util.base64_to_int(rec_priv['q'])
    priv = paillier.PaillierPrivateKey(pub, priv_p, priv_q)
    return pub, priv

def envec_dump_json(pubkey, enc_vals, indent=None):
    """Serializes a vector of encrypted numbers into a simple JSON format."""
    from phe.util import int_to_base64
    R = {}
    R['public_key'] = {
        'n': int_to_base64(pubkey.n),
    }
    R['values'] = [
        (int_to_base64(x.ciphertext()), x.exponent) for x in enc_vals
    ]
    return json.dumps(R, indent=indent)


def envec_load_json(R_json):
    """Deserializes a vector of encrypted numbers."""
    from phe.util import base64_to_int
    R = json.loads(R_json)
    R_pubkey = R['public_key']
    R_values = R['values']

    # deserialized values:
    pubkey_d = paillier.PaillierPublicKey(n=base64_to_int(R_pubkey['n']))
    values_d = [
        paillier.EncryptedNumber(pubkey_d, ciphertext=base64_to_int(v[0]), exponent=int(v[1]))
        for v in R_values
    ]
    return pubkey_d, values_d

def convert_to_paillier_obj(ciphertext, exp, pub_jwk):
    pub_key=publickey_load_jwk(pub_jwk)
    # return paillier.EncryptedNumber(pub_key, ciphertext=base64_to_int(ciphertext), exponent=exp)
    # return paillier.EncryptedNumber(pub_key, ciphertext=ciphertext, exponent=exp)
    return paillier.EncryptedNumber(pub_key, ciphertext=int(ciphertext), exponent=exp)

def generate_key_pair(length=2048):
  pubkey, privkey = paillier.generate_paillier_keypair(n_length=length)
  return keypair_dump_jwk(pubkey, privkey)

def paillier_obj_to_tuple(x):
    # return (int_to_base64(x.ciphertext()), x.exponent)
    return (x.ciphertext(), x.exponent)

def encrypt_value(pub_jwk, value):
    pub_key=publickey_load_jwk(pub_jwk)
    x = pub_key.encrypt(value)
    # return (int_to_base64(x.ciphertext()), x.exponent)
    return (x.ciphertext(), x.exponent)

def decrypt_value(priv_jwk, pub_jwk, enc_value, exponent):
    pub_key, priv_key = keypair_load_jwk(pub_jwk, priv_jwk)
    # x = paillier.EncryptedNumber(pub_key, 
    #                             ciphertext=base64_to_int(enc_value), 
    #                             exponent=exponent)
    x = paillier.EncryptedNumber(pub_key, 
                                ciphertext=int(enc_value), 
                                exponent=exponent)
    dec_value = priv_key.decrypt(x)
    return dec_value

if __name__ == "__main__":
    plain_text = 5
    pubkey, privkey = generate_key_pair()
    (cipher_text, exp) = encrypt_value(pubkey, plain_text)
    # decrypted_cipher_text = decrypt_value(privkey, pubkey, (cipher_text, exp))
    print("plain_text:",plain_text)
    print("public_key:",pubkey)
    print("private_key:",privkey)
    print("cipher_text:",cipher_text)
    print("exp:",exp)
    # print("decrypted_cipher_text:",decrypted_cipher_text)